{"version":3,"names":[],"mappings":"","sources":["src/js/rubik.js"],"sourcesContent":["/* jshint esversion: 6 */\n/* global window, document, TweenMax, ThreeJs */\n\nimport Dom from './shared/dom';\nimport DragListener from './shared/drag.listener';\nimport { RoundBoxGeometry } from './shared/RoundBoxGeometry';\n\nTHREE.Euler.prototype.add = function(euler) {\n\tthis.set(this.x + euler.x, this.y + euler.y, this.z + euler.z, this.order);\n\treturn this;\n};\n\nconst USE_ORTHO = false;\nconst SHOW_HELPERS = false;\n\nclass Rubik {\n\n\tconstructor() {\n\t\tthis.mouse = { x: 0, y: 0 };\n\t\tthis.parallax = { x: 0, y: 0 };\n\t\tthis.size = { width: 0, height: 0, aspect: 0 };\n\t}\n\n\tinit() {\n\t\tconst body = document.querySelector('body');\n\t\tconst section = document.querySelector('.rubik');\n\t\tconst container = section.querySelector('.rubik__container');\n\t\t// const shadow = section.querySelector('.rubik__shadow');\n\t\tconst title = section.querySelector('.rubik__headline .title');\n\t\tconst abstract = section.querySelector('.rubik__headline .abstract');\n\t\tDom.detect(body);\n\t\tbody.classList.add('ready');\n\t\tconst rubikTextureSrc = container.getAttribute('texture');\n\t\tconst loader = new THREE.TextureLoader();\n\t\tloader.crossOrigin = '';\n\t\tloader.load(rubikTextureSrc, (texture) => {\n\t\t\t// texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\t\t\t// texture.repeat.set(2, 2);\n\t\t\tthis.rubikTexture = texture;\n\t\t\tthis.createScene();\n\t\t});\n\t\tthis.body = body;\n\t\tthis.section = section;\n\t\tthis.container = container;\n\t\t// this.shadow = shadow;\n\t\tthis.title = title;\n\t\tthis.abstract = abstract;\n\t\tthis.loader = loader;\n\t}\n\n\tcreateScene() {\n\t\tconst renderer = new THREE.WebGLRenderer({\n\t\t\talpha: true,\n\t\t\tantialias: true\n\t\t});\n\t\trenderer.shadowMap.enabled = true;\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\t\tthis.renderer = renderer;\n\t\t// container.innerHTML = '';\n\t\tthis.container.appendChild(renderer.domElement);\n\t\tconst scene = new THREE.Scene();\n\t\tscene.fog = new THREE.FogExp2(0x000000, 0.1); // new THREE.Fog(0x000000, 0, 10);\n\t\tthis.scene = scene;\n\t\tlet camera;\n\t\tif (USE_ORTHO) {\n\t\t\tconst width = 10;\n\t\t\tconst height = width / this.container.offsetWidth * this.container.offsetHeight;\n\t\t\tcamera = new THREE.OrthographicCamera(-width, width, height, -height, 0.01, 1000);\n\t\t} else {\n\t\t\tcamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);\n\t\t}\n\t\t// const camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0.01, 1000);\n\t\tcamera.position.set(0, 5.0, 12.0);\n\t\tcamera.up = new THREE.Vector3(0, 0, -1);\n\t\tcamera.lookAt(new THREE.Vector3(0, 0, 0));\n\t\tthis.camera = camera;\n\t\tconst ambient = new THREE.AmbientLight(0x222222);\n\t\tscene.add(ambient);\n\t\tthis.ambient = ambient;\n\t\tlet light1;\n\t\tlight1 = new THREE.DirectionalLight(0xffffff, 4.0);\n\t\t// light1.castShadow = true;\n\t\t// light1.shadowCameraVisible = true;\n\t\t// light1.mapSize.width = 2048;\n\t\t// light1.mapSize.height = 2048;\n\t\tscene.add(light1);\n\t\tthis.light1 = light1;\n\t\tif (SHOW_HELPERS) {\n\t\t\tconst light1Helper = new THREE.DirectionalLightHelper(light1, 1);\n\t\t\tscene.add(light1Helper);\n\t\t}\n\t\tconst light2 = new THREE.DirectionalLight(0xffffff, 4.0);\n\t\tscene.add(light2);\n\t\tthis.light2 = light2;\n\t\tif (SHOW_HELPERS) {\n\t\t\tconst light2Helper = new THREE.DirectionalLightHelper(light2, 1);\n\t\t\tscene.add(light2Helper);\n\t\t}\n\t\tconst particleRef = new THREE.Vector3(0.0, 0.0, 1.0);\n\t\tthis.particleRef = particleRef;\n\t\t// const shadow = this.addShadow(scene);\n\t\tconst rubikRotation = new THREE.Euler(0.0, Math.PI * 1.2, 0.0, 'XYZ');\n\t\tconst rubikDragRotation = new THREE.Euler(0, 0, 0, 'XYZ');\n\t\tconst rubikStartDragRotation = new THREE.Euler(0, 0, 0, 'XYZ');\n\t\tconst rubikSpeedRotation = new THREE.Euler(0, 0, 0, 'XYZ');\n\t\tconst rubik = this.addRubik(scene, rubikRotation, this.rubikTexture);\n\t\tthis.rubikRotation = rubikRotation;\n\t\tthis.rubikDragRotation = rubikDragRotation;\n\t\tthis.rubikStartDragRotation = rubikStartDragRotation;\n\t\tthis.rubikSpeedRotation = rubikSpeedRotation;\n\t\tthis.rubikRotation = rubikRotation;\n\t\tthis.rubik = rubik;\n\t\t/*\n\t\tconst particles = addParticles(rubik);\n\t\tthis.particles = particles;\n\t\t*/\n\t\tconst dragListener = new DragListener(this.container, (e) => {\n\t\t\trubikStartDragRotation.copy(rubikDragRotation);\n\t\t}, (e) => {\n\t\t\trubikDragRotation.copy(rubikStartDragRotation).add(new THREE.Euler(0, Math.PI * e.strength.x, 0, 'XYZ'));\n\t\t\trubikSpeedRotation.set(0, 0.1, 0, 'XYZ');\n\t\t}, (e) => {\n\t\t\trubikSpeedRotation.set(0, Math.PI * e.speed.x, 0, 'XYZ');\n\t\t});\n\t\tthis.dragListener = dragListener;\n\t\tthis.onWindowResize = this.onWindowResize.bind(this);\n\t\tthis.onMouseMove = this.onMouseMove.bind(this);\n\t\tthis.onClick = this.onClick.bind(this);\n\t\twindow.addEventListener('resize', this.onWindowResize, false);\n\t\tdocument.addEventListener('mousemove', this.onMouseMove, false);\n\t\tthis.container.addEventListener('click', this.onClick, false);\n\t\tthis.section.classList.add('init');\n\t\tthis.play();\n\t\tthis.onWindowResize();\n\t}\n\n\t/*\n\taddShadow(parent) {\n\t\tconst geometry = new THREE.PlaneGeometry(100, 100);\n\t\tgeometry.rotateX(-Math.PI / 4);\n\t\tconst material = new THREE.ShadowMaterial();\n\t\tmaterial.opacity = 0.2;\n\t\tconst mesh = new THREE.Mesh(geometry, material);\n\t\tmesh.position.z = -0.6;\n\t\tmesh.receiveShadow = true;\n\t\tparent.add(mesh);\n\t\treturn mesh;\n\t}\n\t*/\n\n\taddRubik(parent, rotation, texture) {\n\t\tconst group = new THREE.Group();\n\t\tconst step = 3;\n\t\tconst count = step * step * step;\n\t\tconst size = 1;\n\t\tconst factor = 4;\n\t\tconst duration = 1.4;\n\t\tconst delay = 0.01;\n\t\tconst rows = new Array(step).fill(null).map((dymmy, i) => {\n\t\t\tconst row = new THREE.Group();\n\t\t\tconst d = (step - size) / 2;\n\t\t\tconst position = new THREE.Vector3(0, i - d, 0);\n\t\t\trow.position.set(position.x, position.y, position.z);\n\t\t\tgroup.add(row);\n\t\t\treturn row;\n\t\t});\n\t\tconst cubes = new Array(count).fill(null).map((dummy, i) => {\n\t\t\tconst x = Math.floor(i / (step * step));\n\t\t\tconst y = Math.floor(i / step) % step;\n\t\t\tconst z = i % step;\n\t\t\tconst d = (step - size) / 2;\n\t\t\tconst row = rows[y];\n\t\t\t// const position = new THREE.Vector3(x - d, y - d, z - d);\n\t\t\tconst positionCube = new THREE.Vector3(x - d, 0, z - d);\n\t\t\t// console.log(x, y, z, positionCube);\n\t\t\tconst cube = this.addCube(row, positionCube, texture, i, factor, duration, delay);\n\t\t\treturn cube;\n\t\t});\n\t\tgroup.rows = rows;\n\t\tgroup.cubes = cubes;\n\t\tgroup.rotation.set(rotation.x, rotation.y, rotation.z);\n\t\tparent.add(group);\n\t\treturn group;\n\t}\n\n\taddCube(parent, position, texture, i, factor, duration, delay) {\n\t\tconst geometry = RoundBoxGeometry(1.0, 1.0, 1.0, 0.1, 2, 2, 2, 5);\n\t\ttexture = texture.clone();\n\t\ttexture.needsUpdate = true;\n\t\ttexture.rotation = -0.02 + Math.random() * 0.04;\n\t\tconst material = new THREE.MeshStandardMaterial({\n\t\t\tcolor: '#fefefe',\n\t\t\troughness: 0.9,\n\t\t\tmetalness: 0.1,\n\t\t\troughnessMap: texture,\n\t\t\tmap: texture,\n\t\t\ttransparent: true,\n\t\t\topacity: 0,\n\t\t\t// premultipliedAlpha: true,\n\t\t});\n\t\t/*\n\t\tconst materials = [\n\t\t\tmaterial,\n\t\t\tmaterial,\n\t\t\tmaterial,\n\t\t\tmaterial,\n\t\t\tmaterial,\n\t\t\tmaterial\n\t\t];\n\t\t*/\n\t\tconst mesh = new THREE.Mesh(geometry, material);\n\t\tmesh.castShadow = true;\n\t\tmesh.receiveShadow = false;\n\t\tmesh.position_ = position;\n\t\tmesh.position.set(position.x * factor, position.y * factor, position.z * factor);\n\t\tparent.add(mesh);\n\t\treturn mesh;\n\t}\n\n\tenter() {\n\t\tthis.rubikCubesAppearAnimation();\n\t}\n\n\trubikCubesAppearAnimation(factor, duration, delay) {\n\t\tconst cubes = this.rubik.cubes;\n\t\tfactor = factor || 4;\n\t\tduration = duration || 1.4;\n\t\tdelay = delay || 0.01;\n\t\tcubes.forEach((cube, i) => {\n\t\t\tconst position = cube.position_;\n\t\t\tcube.position.set(position.x * factor, position.y * factor, position.z * factor);\n\t\t\tTweenMax.to(cube.position, duration, {\n\t\t\t\tx: position.x,\n\t\t\t\ty: position.y,\n\t\t\t\tz: position.z,\n\t\t\t\tdelay: i * delay,\n\t\t\t\tease: Elastic.easeOut,\n\t\t\t});\n\t\t\tTweenMax.to(cube.material, duration * 0.2, {\n\t\t\t\topacity: 1,\n\t\t\t\tdelay: i * delay,\n\t\t\t\tease: Sine.easeInOut,\n\t\t\t});\n\t\t});\n\t\tsetTimeout(() => {\n\t\t\tthis.randomRotateRubikRows(this.rubik.rows);\n\t\t\tTweenMax.set(this.title, { transform: 'translate3d(0,80px,0)' });\n\t\t\tTweenMax.to(this.title, 0.4, {\n\t\t\t\ttransform: 'translate3d(0,0,0)',\n\t\t\t\topacity: 1,\n\t\t\t\tdelay: 1,\n\t\t\t\tease: Sine.easeInOut,\n\t\t\t});\n\t\t\tTweenMax.set(this.abstract, { transform: 'translate3d(0,80px,0)' });\n\t\t\tTweenMax.to(this.abstract, 0.4, {\n\t\t\t\ttransform: 'translate3d(0,0,0)',\n\t\t\t\topacity: 1,\n\t\t\t\tdelay: 1.2,\n\t\t\t\tease: Sine.easeInOut,\n\t\t\t});\n\t\t}, delay * cubes.length + duration);\n\t}\n\n\trubikCubesWaveAnimation(cubes, factor, duration, delay) {\n\t\tfactor = factor || 1.5;\n\t\tduration = duration || 1.4;\n\t\tdelay = delay || 0.01;\n\t\tcubes.forEach((cube, i) => {\n\t\t\tconst position = cube.position_;\n\t\t\tTweenMax.to(cube.position, 0.3, {\n\t\t\t\tx: position.x * factor,\n\t\t\t\ty: position.y * factor,\n\t\t\t\tz: position.z * factor,\n\t\t\t\tdelay: i * delay,\n\t\t\t\tease: Sine.easeOut,\n\t\t\t\tonComplete: () => {\n\t\t\t\t\tTweenMax.to(cube.position, duration, {\n\t\t\t\t\t\tx: position.x,\n\t\t\t\t\t\ty: position.y,\n\t\t\t\t\t\tz: position.z,\n\t\t\t\t\t\tease: Elastic.easeOut,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\trandomRotateRubikRows(rows) {\n\t\t// console.log(rows);\n\t\tconst dir = Math.random() > 0.5 ? 1 : -1;\n\t\tconst row = rows[Math.floor(Math.random() * rows.length)];\n\t\tconst rotation = row.rotation;\n\t\tTweenMax.to(rotation, 0.5, {\n\t\t\ty: rotation.y + dir * Math.PI / 2,\n\t\t\tdelay: 1,\n\t\t\tease: Sine.easeInOut,\n\t\t\tonComplete: () => {\n\t\t\t\tthis.randomRotateRubikRows(rows);\n\t\t\t}\n\t\t});\n\t}\n\n\tonClick(e) {\n\t\tthis.rubikCubesWaveAnimation(this.rubik.cubes);\n\t}\n\n\tonWindowResize() {\n\t\tconst container = this.container,\n\t\t\trenderer = this.renderer,\n\t\t\tcamera = this.camera;\n\t\tconst size = this.size;\n\t\tsize.width = container.offsetWidth;\n\t\t/*\n\t\tTweenMax.set(container, {\n\t\t\theight: container.offsetWidth * 0.6\n\t\t});\n\t\t*/\n\t\tsize.height = container.offsetHeight;\n\t\tsize.aspect = size.width / size.height;\n\t\tif (renderer) {\n\t\t\trenderer.setSize(size.width, size.height);\n\t\t}\n\t\tif (camera) {\n\t\t\tif (USE_ORTHO) {\n\t\t\t\tconst width = 10; // !!! 3 - 10\n\t\t\t\tconst height = width / this.container.offsetWidth * this.container.offsetHeight;\n\t\t\t\tcamera.left = -width;\n\t\t\t\tcamera.right = width;\n\t\t\t\tcamera.top = height;\n\t\t\t\tcamera.bottom = -height;\n\t\t\t} else {\n\t\t\t\tcamera.aspect = size.width / size.height;\n\t\t\t\tcamera.zoom = 1.2;\n\t\t\t}\n\t\t\tcamera.updateProjectionMatrix();\n\t\t}\n\t}\n\n\tonMouseMove(e) {\n\t\tconst w2 = window.innerWidth / 2;\n\t\tconst h2 = window.innerHeight / 2;\n\t\tthis.mouse = {\n\t\t\tx: (e.clientX - w2) / w2,\n\t\t\ty: (e.clientY - h2) / h2,\n\t\t};\n\t\t// console.log('onMouseMove', this.mouse);\n\t}\n\n\tdoParallax() {\n\t\t// parallax\n\t\tconst parallax = this.parallax;\n\t\tparallax.x += (this.mouse.x - parallax.x) / 8;\n\t\tparallax.y += (this.mouse.y - parallax.y) / 8;\n\t\tconst size = this.size;\n\t\tconst sx = size.width < 1024 ? 0 : -3;\n\t\tconst sy = size.width < 1024 ? -2 : 0;\n\t\tthis.rubik.position.x = sx + parallax.x * 0.2;\n\t\tthis.rubik.position.y = sy + parallax.y * 0.2;\n\t\t//\n\t\t/*\n\t\tconst titleXy = {\n\t\t\tx: -50 + 0.5 * -parallax.x,\n\t\t\ty: -50 + 0.5 * -parallax.y,\n\t\t};\n\t\tTweenMax.set(this.title, {\n\t\t\ttransform: 'translateX(' + titleXy.x + '%) translateY(' + titleXy.y + '%)'\n\t\t});\n\t\t*/\n\t\t/*\n\t\tconst shadowXy = {\n\t\t\tx: -50 + 3 * -parallax.x,\n\t\t\ty: -50 + 3 * -parallax.y,\n\t\t};\n\t\tTweenMax.set(this.shadow, {\n\t\t\ttransform: 'translateX(' + shadowXy.x + '%) translateY(' + shadowXy.y + '%)'\n\t\t});\n\t\t*/\n\t\tthis.light1.position.set(parallax.x * 5.0, 6.0 + parallax.y * 2.0, 4.0);\n\t\tthis.light2.position.set(parallax.x * -5.0, -6.0 - parallax.y * 2.0, 4.0);\n\t}\n\n\trender(delta) {\n\t\tif (!this.dragListener.dragging) {\n\t\t\tthis.rubikRotation.y += this.rubikSpeedRotation.y;\n\t\t\tthis.rubikSpeedRotation.y += (0.002 - this.rubikSpeedRotation.y) / 50;\n\t\t}\n\t\tthis.rubik.rotation.copy(this.rubikRotation).add(this.rubikDragRotation);\n\t\t/*\n\t\tthis.particles.geometry.vertices.forEach((vertex, i) => {\n\t\t\tconst local = this.rubik.localToWorld(vertex.clone());\n\t\t\tconst distance = local.distanceTo(this.particleRef);\n\t\t\tconst s = Math.max(0, Math.min(1, (1 - distance))) * 5;\n\t\t\tthis.particles.geometry.colors[i] = new THREE.Color(s, s, s);\n\t\t\tthis.particles.geometry.colorsNeedUpdate = true;\n\t\t});\n\t\t*/\n\t\tthis.renderer.render(this.scene, this.camera);\n\t\tthis.doParallax();\n\t}\n\n\tplay() {\n\t\tconst clock = new THREE.Clock();\n\t\tconst loop = (time) => {\n\t\t\tconst delta = clock.getDelta();\n\t\t\tthis.render(delta);\n\t\t\twindow.requestAnimationFrame(loop);\n\t\t};\n\t\tloop();\n\t}\n\n}\n\nvar rubik = new Rubik();\n\nwindow.onload = () => {\n\trubik.init();\n\tsetTimeout(() => {\n\t\tconsole.log(rubik.rubik);\n\t\trubik.enter();\n\t}, 1000);\n};\n"],"file":"docs/js/rubik.js"}