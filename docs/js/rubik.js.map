{"version":3,"names":[],"mappings":"","sources":["src/js/rubik.js"],"sourcesContent":["/* jshint esversion: 6 */\r\n/* global window, document, TweenMax, ThreeJs */\r\n\r\nimport Dom from './shared/dom';\r\nimport DragListener from './shared/drag.listener';\r\nimport { RoundBoxGeometry } from './shared/RoundBoxGeometry';\r\n\r\nTHREE.Euler.prototype.add = function(euler) {\r\n\tthis.set(this.x + euler.x, this.y + euler.y, this.z + euler.z, this.order);\r\n\treturn this;\r\n};\r\n\r\nconst USE_ORTHO = false;\r\nconst SHOW_HELPERS = false;\r\n\r\nclass Rubik {\r\n\r\n\tconstructor() {\r\n\t\tthis.mouse = { x: 0, y: 0 };\r\n\t\tthis.parallax = { x: 0, y: 0 };\r\n\t\tthis.size = { width: 0, height: 0, aspect: 0 };\r\n\t}\r\n\r\n\tinit() {\r\n\t\tconst body = document.querySelector('body');\r\n\t\tconst section = document.querySelector('.rubik');\r\n\t\tconst container = section.querySelector('.rubik__container');\r\n\t\t// const shadow = section.querySelector('.rubik__shadow');\r\n\t\tconst title = section.querySelector('.rubik__headline .title');\r\n\t\tconst abstract = section.querySelector('.rubik__headline .abstract');\r\n\t\tDom.detect(body);\r\n\t\tbody.classList.add('ready');\r\n\t\tconst rubikTextureSrc = container.getAttribute('texture');\r\n\t\tconst loader = new THREE.TextureLoader();\r\n\t\tloader.crossOrigin = '';\r\n\t\tloader.load(rubikTextureSrc, (texture) => {\r\n\t\t\t// texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\r\n\t\t\t// texture.repeat.set(2, 2);\r\n\t\t\tthis.rubikTexture = texture;\r\n\t\t\tthis.createScene();\r\n\t\t});\r\n\t\tthis.body = body;\r\n\t\tthis.section = section;\r\n\t\tthis.container = container;\r\n\t\t// this.shadow = shadow;\r\n\t\tthis.title = title;\r\n\t\tthis.abstract = abstract;\r\n\t\tthis.loader = loader;\r\n\t}\r\n\r\n\tcreateScene() {\r\n\t\tconst renderer = new THREE.WebGLRenderer({\r\n\t\t\talpha: true,\r\n\t\t\tantialias: true\r\n\t\t});\r\n\t\trenderer.shadowMap.enabled = true;\r\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\r\n\t\tthis.renderer = renderer;\r\n\t\t// container.innerHTML = '';\r\n\t\tthis.container.appendChild(renderer.domElement);\r\n\t\tconst scene = new THREE.Scene();\r\n\t\tscene.fog = new THREE.FogExp2(0x000000, 0.1); // new THREE.Fog(0x000000, 0, 10);\r\n\t\tthis.scene = scene;\r\n\t\tlet camera;\r\n\t\tif (USE_ORTHO) {\r\n\t\t\tconst width = 10;\r\n\t\t\tconst height = width / this.container.offsetWidth * this.container.offsetHeight;\r\n\t\t\tcamera = new THREE.OrthographicCamera(-width, width, height, -height, 0.01, 1000);\r\n\t\t} else {\r\n\t\t\tcamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);\r\n\t\t}\r\n\t\t// const camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0.01, 1000);\r\n\t\tcamera.position.set(0, 5.0, 12.0);\r\n\t\tcamera.up = new THREE.Vector3(0, 0, -1);\r\n\t\tcamera.lookAt(new THREE.Vector3(0, 0, 0));\r\n\t\tthis.camera = camera;\r\n\t\tconst ambient = new THREE.AmbientLight(0x222222);\r\n\t\tscene.add(ambient);\r\n\t\tthis.ambient = ambient;\r\n\t\tlet light1;\r\n\t\tlight1 = new THREE.DirectionalLight(0xffffff, 4.0);\r\n\t\t// light1.castShadow = true;\r\n\t\t// light1.shadowCameraVisible = true;\r\n\t\t// light1.mapSize.width = 2048;\r\n\t\t// light1.mapSize.height = 2048;\r\n\t\tscene.add(light1);\r\n\t\tthis.light1 = light1;\r\n\t\tif (SHOW_HELPERS) {\r\n\t\t\tconst light1Helper = new THREE.DirectionalLightHelper(light1, 1);\r\n\t\t\tscene.add(light1Helper);\r\n\t\t}\r\n\t\tconst light2 = new THREE.DirectionalLight(0xffffff, 4.0);\r\n\t\tscene.add(light2);\r\n\t\tthis.light2 = light2;\r\n\t\tif (SHOW_HELPERS) {\r\n\t\t\tconst light2Helper = new THREE.DirectionalLightHelper(light2, 1);\r\n\t\t\tscene.add(light2Helper);\r\n\t\t}\r\n\t\tconst particleRef = new THREE.Vector3(0.0, 0.0, 1.0);\r\n\t\tthis.particleRef = particleRef;\r\n\t\t// const shadow = this.addShadow(scene);\r\n\t\tconst rubikRotation = new THREE.Euler(0.0, Math.PI * 1.2, 0.0, 'XYZ');\r\n\t\tconst rubikDragRotation = new THREE.Euler(0, 0, 0, 'XYZ');\r\n\t\tconst rubikStartDragRotation = new THREE.Euler(0, 0, 0, 'XYZ');\r\n\t\tconst rubikSpeedRotation = new THREE.Euler(0, 0, 0, 'XYZ');\r\n\t\tconst rubik = this.addRubik(scene, rubikRotation, this.rubikTexture);\r\n\t\tthis.rubikRotation = rubikRotation;\r\n\t\tthis.rubikDragRotation = rubikDragRotation;\r\n\t\tthis.rubikStartDragRotation = rubikStartDragRotation;\r\n\t\tthis.rubikSpeedRotation = rubikSpeedRotation;\r\n\t\tthis.rubikRotation = rubikRotation;\r\n\t\tthis.rubik = rubik;\r\n\t\t/*\r\n\t\tconst particles = addParticles(rubik);\r\n\t\tthis.particles = particles;\r\n\t\t*/\r\n\t\tconst dragListener = new DragListener(this.container, (e) => {\r\n\t\t\trubikStartDragRotation.copy(rubikDragRotation);\r\n\t\t}, (e) => {\r\n\t\t\trubikDragRotation.copy(rubikStartDragRotation).add(new THREE.Euler(0, Math.PI * e.strength.x, 0, 'XYZ'));\r\n\t\t\trubikSpeedRotation.set(0, 0.1, 0, 'XYZ');\r\n\t\t}, (e) => {\r\n\t\t\trubikSpeedRotation.set(0, Math.PI * e.speed.x, 0, 'XYZ');\r\n\t\t});\r\n\t\tthis.dragListener = dragListener;\r\n\t\tthis.onWindowResize = this.onWindowResize.bind(this);\r\n\t\tthis.onMouseMove = this.onMouseMove.bind(this);\r\n\t\tthis.onClick = this.onClick.bind(this);\r\n\t\twindow.addEventListener('resize', this.onWindowResize, false);\r\n\t\tdocument.addEventListener('mousemove', this.onMouseMove, false);\r\n\t\tthis.container.addEventListener('click', this.onClick, false);\r\n\t\tthis.section.classList.add('init');\r\n\t\tthis.play();\r\n\t\tthis.onWindowResize();\r\n\t}\r\n\r\n\t/*\r\n\taddShadow(parent) {\r\n\t\tconst geometry = new THREE.PlaneGeometry(100, 100);\r\n\t\tgeometry.rotateX(-Math.PI / 4);\r\n\t\tconst material = new THREE.ShadowMaterial();\r\n\t\tmaterial.opacity = 0.2;\r\n\t\tconst mesh = new THREE.Mesh(geometry, material);\r\n\t\tmesh.position.z = -0.6;\r\n\t\tmesh.receiveShadow = true;\r\n\t\tparent.add(mesh);\r\n\t\treturn mesh;\r\n\t}\r\n\t*/\r\n\r\n\taddRubik(parent, rotation, texture) {\r\n\t\tconst group = new THREE.Group();\r\n\t\tconst step = 3;\r\n\t\tconst count = step * step * step;\r\n\t\tconst size = 1;\r\n\t\tconst factor = 4;\r\n\t\tconst duration = 1.4;\r\n\t\tconst delay = 0.01;\r\n\t\tconst rows = new Array(step).fill(null).map((dymmy, i) => {\r\n\t\t\tconst row = new THREE.Group();\r\n\t\t\tconst d = (step - size) / 2;\r\n\t\t\tconst position = new THREE.Vector3(0, i - d, 0);\r\n\t\t\trow.position.set(position.x, position.y, position.z);\r\n\t\t\tgroup.add(row);\r\n\t\t\treturn row;\r\n\t\t});\r\n\t\tconst cubes = new Array(count).fill(null).map((dummy, i) => {\r\n\t\t\tconst x = Math.floor(i / (step * step));\r\n\t\t\tconst y = Math.floor(i / step) % step;\r\n\t\t\tconst z = i % step;\r\n\t\t\tconst d = (step - size) / 2;\r\n\t\t\tconst row = rows[y];\r\n\t\t\t// const position = new THREE.Vector3(x - d, y - d, z - d);\r\n\t\t\tconst positionCube = new THREE.Vector3(x - d, 0, z - d);\r\n\t\t\t// console.log(x, y, z, positionCube);\r\n\t\t\tconst cube = this.addCube(row, positionCube, texture, i, factor, duration, delay);\r\n\t\t\treturn cube;\r\n\t\t});\r\n\t\tgroup.rows = rows;\r\n\t\tgroup.cubes = cubes;\r\n\t\tgroup.rotation.set(rotation.x, rotation.y, rotation.z);\r\n\t\tparent.add(group);\r\n\t\treturn group;\r\n\t}\r\n\r\n\taddCube(parent, position, texture, i, factor, duration, delay) {\r\n\t\tconst geometry = RoundBoxGeometry(1.0, 1.0, 1.0, 0.1, 2, 2, 2, 5);\r\n\t\ttexture = texture.clone();\r\n\t\ttexture.needsUpdate = true;\r\n\t\ttexture.rotation = -0.02 + Math.random() * 0.04;\r\n\t\tconst material = new THREE.MeshStandardMaterial({\r\n\t\t\tcolor: '#fefefe',\r\n\t\t\troughness: 0.9,\r\n\t\t\tmetalness: 0.1,\r\n\t\t\troughnessMap: texture,\r\n\t\t\tmap: texture,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0,\r\n\t\t\t// premultipliedAlpha: true,\r\n\t\t});\r\n\t\t/*\r\n\t\tconst materials = [\r\n\t\t\tmaterial,\r\n\t\t\tmaterial,\r\n\t\t\tmaterial,\r\n\t\t\tmaterial,\r\n\t\t\tmaterial,\r\n\t\t\tmaterial\r\n\t\t];\r\n\t\t*/\r\n\t\tconst mesh = new THREE.Mesh(geometry, material);\r\n\t\tmesh.castShadow = true;\r\n\t\tmesh.receiveShadow = false;\r\n\t\tmesh.position_ = position;\r\n\t\tmesh.position.set(position.x * factor, position.y * factor, position.z * factor);\r\n\t\tparent.add(mesh);\r\n\t\treturn mesh;\r\n\t}\r\n\r\n\tenter() {\r\n\t\tthis.rubikCubesAppearAnimation();\r\n\t}\r\n\r\n\trubikCubesAppearAnimation(factor, duration, delay) {\r\n\t\tconst cubes = this.rubik.cubes;\r\n\t\tfactor = factor || 1.5;\r\n\t\tduration = duration || 1.4;\r\n\t\tdelay = delay || 0.01;\r\n\t\tcubes.forEach((cube, i) => {\r\n\t\t\tconst position = cube.position_;\r\n\t\t\tcube.position.set(position.x * factor, position.y * factor, position.z * factor);\r\n\t\t\tTweenMax.to(cube.position, duration, {\r\n\t\t\t\tx: position.x,\r\n\t\t\t\ty: position.y,\r\n\t\t\t\tz: position.z,\r\n\t\t\t\tdelay: i * delay,\r\n\t\t\t\tease: Elastic.easeOut,\r\n\t\t\t});\r\n\t\t\tTweenMax.to(cube.material, duration * 0.2, {\r\n\t\t\t\topacity: 1,\r\n\t\t\t\tdelay: i * delay,\r\n\t\t\t\tease: Sine.easeInOut,\r\n\t\t\t});\r\n\t\t});\r\n\t\tsetTimeout(() => {\r\n\t\t\tthis.randomRotateRubikRows(this.rubik.rows);\r\n\t\t\tTweenMax.set(this.title, { transform: 'translate3d(0,80px,0)' });\r\n\t\t\tTweenMax.to(this.title, 0.4, {\r\n\t\t\t\ttransform: 'translate3d(0,0,0)',\r\n\t\t\t\topacity: 1,\r\n\t\t\t\tdelay: 1,\r\n\t\t\t\tease: Sine.easeInOut,\r\n\t\t\t});\r\n\t\t\tTweenMax.set(this.abstract, { transform: 'translate3d(0,80px,0)' });\r\n\t\t\tTweenMax.to(this.abstract, 0.4, {\r\n\t\t\t\ttransform: 'translate3d(0,0,0)',\r\n\t\t\t\topacity: 1,\r\n\t\t\t\tdelay: 1.2,\r\n\t\t\t\tease: Sine.easeInOut,\r\n\t\t\t});\r\n\t\t}, delay * cubes.length + duration);\r\n\t}\r\n\r\n\trubikCubesWaveAnimation(cubes, factor, duration, delay) {\r\n\t\tfactor = factor || 1.5;\r\n\t\tduration = duration || 1.4;\r\n\t\tdelay = delay || 0.01;\r\n\t\tcubes.forEach((cube, i) => {\r\n\t\t\tconst position = cube.position_;\r\n\t\t\tTweenMax.to(cube.position, 0.3, {\r\n\t\t\t\tx: position.x * factor,\r\n\t\t\t\ty: position.y * factor,\r\n\t\t\t\tz: position.z * factor,\r\n\t\t\t\tdelay: i * delay,\r\n\t\t\t\tease: Sine.easeOut,\r\n\t\t\t\tonComplete: () => {\r\n\t\t\t\t\tTweenMax.to(cube.position, duration, {\r\n\t\t\t\t\t\tx: position.x,\r\n\t\t\t\t\t\ty: position.y,\r\n\t\t\t\t\t\tz: position.z,\r\n\t\t\t\t\t\tease: Elastic.easeOut,\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\trandomRotateRubikRows(rows) {\r\n\t\t// console.log(rows);\r\n\t\tconst dir = Math.random() > 0.5 ? 1 : -1;\r\n\t\tconst row = rows[Math.floor(Math.random() * rows.length)];\r\n\t\tconst rotation = row.rotation;\r\n\t\tTweenMax.to(rotation, 0.5, {\r\n\t\t\ty: rotation.y + dir * Math.PI / 2,\r\n\t\t\tdelay: 1,\r\n\t\t\tease: Sine.easeInOut,\r\n\t\t\tonComplete: () => {\r\n\t\t\t\tthis.randomRotateRubikRows(rows);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tonClick(e) {\r\n\t\tthis.rubikCubesWaveAnimation(this.rubik.cubes);\r\n\t}\r\n\r\n\tonWindowResize() {\r\n\t\tconst container = this.container,\r\n\t\t\trenderer = this.renderer,\r\n\t\t\tcamera = this.camera;\r\n\t\tconst size = this.size;\r\n\t\tsize.width = container.offsetWidth;\r\n\t\t/*\r\n\t\tTweenMax.set(container, {\r\n\t\t\theight: container.offsetWidth * 0.6\r\n\t\t});\r\n\t\t*/\r\n\t\tsize.height = container.offsetHeight;\r\n\t\tsize.aspect = size.width / size.height;\r\n\t\tif (renderer) {\r\n\t\t\trenderer.setSize(size.width, size.height);\r\n\t\t}\r\n\t\tif (camera) {\r\n\t\t\tif (USE_ORTHO) {\r\n\t\t\t\tconst width = 10; // !!! 3 - 10\r\n\t\t\t\tconst height = width / this.container.offsetWidth * this.container.offsetHeight;\r\n\t\t\t\tcamera.left = -width;\r\n\t\t\t\tcamera.right = width;\r\n\t\t\t\tcamera.top = height;\r\n\t\t\t\tcamera.bottom = -height;\r\n\t\t\t} else {\r\n\t\t\t\tcamera.aspect = size.width / size.height;\r\n\t\t\t\tcamera.zoom = 1.2;\r\n\t\t\t}\r\n\t\t\tcamera.updateProjectionMatrix();\r\n\t\t}\r\n\t}\r\n\r\n\tonMouseMove(e) {\r\n\t\tconst w2 = window.innerWidth / 2;\r\n\t\tconst h2 = window.innerHeight / 2;\r\n\t\tthis.mouse = {\r\n\t\t\tx: (e.clientX - w2) / w2,\r\n\t\t\ty: (e.clientY - h2) / h2,\r\n\t\t};\r\n\t\t// console.log('onMouseMove', this.mouse);\r\n\t}\r\n\r\n\tdoParallax() {\r\n\t\t// parallax\r\n\t\tconst parallax = this.parallax;\r\n\t\tparallax.x += (this.mouse.x - parallax.x) / 8;\r\n\t\tparallax.y += (this.mouse.y - parallax.y) / 8;\r\n\t\tconst size = this.size;\r\n\t\tconst sx = size.width < 1024 ? 0 : -3;\r\n\t\tconst sy = size.width < 1024 ? -2 : 0;\r\n\t\tthis.rubik.position.x = sx + parallax.x * 0.2;\r\n\t\tthis.rubik.position.y = sy + parallax.y * 0.2;\r\n\t\t//\r\n\t\t/*\r\n\t\tconst titleXy = {\r\n\t\t\tx: -50 + 0.5 * -parallax.x,\r\n\t\t\ty: -50 + 0.5 * -parallax.y,\r\n\t\t};\r\n\t\tTweenMax.set(this.title, {\r\n\t\t\ttransform: 'translateX(' + titleXy.x + '%) translateY(' + titleXy.y + '%)'\r\n\t\t});\r\n\t\t*/\r\n\t\t/*\r\n\t\tconst shadowXy = {\r\n\t\t\tx: -50 + 3 * -parallax.x,\r\n\t\t\ty: -50 + 3 * -parallax.y,\r\n\t\t};\r\n\t\tTweenMax.set(this.shadow, {\r\n\t\t\ttransform: 'translateX(' + shadowXy.x + '%) translateY(' + shadowXy.y + '%)'\r\n\t\t});\r\n\t\t*/\r\n\t\tthis.light1.position.set(parallax.x * 5.0, 6.0 + parallax.y * 2.0, 4.0);\r\n\t\tthis.light2.position.set(parallax.x * -5.0, -6.0 - parallax.y * 2.0, 4.0);\r\n\t}\r\n\r\n\trender(delta) {\r\n\t\tif (!this.dragListener.dragging) {\r\n\t\t\tthis.rubikRotation.y += this.rubikSpeedRotation.y;\r\n\t\t\tthis.rubikSpeedRotation.y += (0.002 - this.rubikSpeedRotation.y) / 50;\r\n\t\t}\r\n\t\tthis.rubik.rotation.copy(this.rubikRotation).add(this.rubikDragRotation);\r\n\t\t/*\r\n\t\tthis.particles.geometry.vertices.forEach((vertex, i) => {\r\n\t\t\tconst local = this.rubik.localToWorld(vertex.clone());\r\n\t\t\tconst distance = local.distanceTo(this.particleRef);\r\n\t\t\tconst s = Math.max(0, Math.min(1, (1 - distance))) * 5;\r\n\t\t\tthis.particles.geometry.colors[i] = new THREE.Color(s, s, s);\r\n\t\t\tthis.particles.geometry.colorsNeedUpdate = true;\r\n\t\t});\r\n\t\t*/\r\n\t\tthis.renderer.render(this.scene, this.camera);\r\n\t\tthis.doParallax();\r\n\t}\r\n\r\n\tplay() {\r\n\t\tconst clock = new THREE.Clock();\r\n\t\tconst loop = (time) => {\r\n\t\t\tconst delta = clock.getDelta();\r\n\t\t\tthis.render(delta);\r\n\t\t\twindow.requestAnimationFrame(loop);\r\n\t\t};\r\n\t\tloop();\r\n\t}\r\n\r\n}\r\n\r\nvar rubik = new Rubik();\r\n\r\nwindow.onload = () => {\r\n\trubik.init();\r\n\tsetTimeout(() => {\r\n\t\tconsole.log(rubik.rubik);\r\n\t\trubik.enter();\r\n\t}, 1000);\r\n};\r\n"],"file":"docs\\js\\rubik.js"}