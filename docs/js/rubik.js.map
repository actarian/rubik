{"version":3,"names":[],"mappings":"","sources":["src/js/rubik.js"],"sourcesContent":["/* jshint esversion: 6 */\n/* global window, document, TweenMax, ThreeJs */\n\nimport Dom from './shared/dom';\nimport DragListener from './shared/drag.listener';\nimport { RoundBoxGeometry } from './shared/RoundBoxGeometry';\n\nTHREE.Euler.prototype.add = function(euler) {\n\tthis.set(this.x + euler.x, this.y + euler.y, this.z + euler.z, this.order);\n\treturn this;\n};\n\nconst USE_ORTHO = false;\n\nclass Rubik {\n\n\tconstructor() {\n\t\tthis.mouse = { x: 0, y: 0 };\n\t\tthis.parallax = { x: 0, y: 0 };\n\t\tthis.cities = [\n\t\t\t[43.9096538, 12.8399805], // pesaro\n\t\t\t[41.8519772, 12.2347364], // rome\n\t\t\t[51.5287718, -0.2416791], // london\n\t\t\t[55.6713812, 12.4537393], // copenaghen\n\t\t\t[40.6976637, -74.1197623], // new york\n\t\t\t[19.3911668, -99.4238221], // mexico city\n\t\t\t[39.9390731, 116.11726], // beijing\n\t\t\t[31.2243084, 120.9162376], // shangai\n\t\t];\n\t}\n\n\tinit() {\n\t\tconst body = document.querySelector('body');\n\t\tconst section = document.querySelector('.rubik');\n\t\tconst container = section.querySelector('.rubik__container');\n\t\tconst shadow = section.querySelector('.rubik__shadow');\n\t\tconst title = section.querySelector('.rubik__headline');\n\t\tDom.detect(body);\n\t\tbody.classList.add('ready');\n\t\tconst rubikTextureSrc = container.getAttribute('texture');\n\t\tconst loader = new THREE.TextureLoader();\n\t\tloader.crossOrigin = '';\n\t\tloader.load(rubikTextureSrc, (texture) => {\n\t\t\t// texture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\t\t\t// texture.repeat.set(2, 2);\n\t\t\tthis.rubikTexture = texture;\n\t\t\tthis.createScene();\n\t\t});\n\t\tthis.body = body;\n\t\tthis.section = section;\n\t\tthis.container = container;\n\t\tthis.shadow = shadow;\n\t\tthis.title = title;\n\t\tthis.loader = loader;\n\t}\n\n\tcreateScene() {\n\t\tconst renderer = new THREE.WebGLRenderer({\n\t\t\talpha: true,\n\t\t\tantialias: true\n\t\t});\n\t\trenderer.shadowMap.enabled = true;\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\t\tthis.renderer = renderer;\n\n\t\t// container.innerHTML = '';\n\t\tthis.container.appendChild(renderer.domElement);\n\t\tconst scene = new THREE.Scene();\n\t\tscene.fog = new THREE.FogExp2(0x000000, 0.1); // new THREE.Fog(0x000000, 0, 10);\n\t\tthis.scene = scene;\n\n\t\tlet camera;\n\t\tif (USE_ORTHO) {\n\t\t\tconst width = 10;\n\t\t\tconst height = width / this.container.offsetWidth * this.container.offsetHeight;\n\t\t\tcamera = new THREE.OrthographicCamera(-width, width, height, -height, 0.01, 1000);\n\t\t} else {\n\t\t\tcamera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.01, 1000);\n\t\t}\n\t\t/*\n\t\t */\n\t\t// const camera = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 0.01, 1000);\n\t\tcamera.position.set(0, 5.0, 10.0);\n\t\tcamera.up = new THREE.Vector3(0, 0, -1);\n\t\tcamera.lookAt(new THREE.Vector3(0, 0, 0));\n\t\tthis.camera = camera;\n\n\t\tconst ambient = new THREE.AmbientLight(0x222222);\n\t\tscene.add(ambient);\n\t\tthis.ambient = ambient;\n\n\t\tlet directional1;\n\t\tdirectional1 = new THREE.DirectionalLight(0xffffff, 10.0);\n\t\tdirectional1.position.set(0, 6.0, -20);\n\t\t// directional1.castShadow = true;\n\t\t// directional1.shadowCameraVisible = true;\n\t\t// directional1.mapSize.width = 2048;\n\t\t// directional1.mapSize.height = 2048;\n\t\tscene.add(directional1);\n\t\tthis.directional1 = directional1;\n\n\t\tconst directional2 = new THREE.DirectionalLight(0xffffff, 10.0);\n\t\tdirectional2.position.set(0, -6.0, 20);\n\t\tscene.add(directional2);\n\t\tthis.directional2 = directional2;\n\n\t\tconst particleRef = new THREE.Vector3(0.0, 0.0, 1.0);\n\t\tthis.particleRef = particleRef;\n\n\t\t// const shadow = this.addShadow(scene);\n\n\t\tconst rubikRotation = new THREE.Euler(0.0, Math.PI * 1.2, 0.0, 'XYZ');\n\t\tconst rubikDragRotation = new THREE.Euler(0, 0, 0, 'XYZ');\n\t\tconst rubikStartDragRotation = new THREE.Euler(0, 0, 0, 'XYZ');\n\t\tconst rubikSpeedRotation = new THREE.Euler(0, 0, 0, 'XYZ');\n\t\tconst rubik = this.addRubik(scene, rubikRotation, this.rubikTexture);\n\t\tthis.rubikRotation = rubikRotation;\n\t\tthis.rubikDragRotation = rubikDragRotation;\n\t\tthis.rubikStartDragRotation = rubikStartDragRotation;\n\t\tthis.rubikSpeedRotation = rubikSpeedRotation;\n\t\tthis.rubikRotation = rubikRotation;\n\t\tthis.rubik = rubik;\n\n\t\tconst particles = this.addParticles(rubik);\n\t\tthis.particles = particles;\n\n\t\tconst dragListener = new DragListener(this.container, (e) => {\n\t\t\trubikStartDragRotation.copy(rubikDragRotation);\n\t\t}, (e) => {\n\t\t\trubikDragRotation.copy(rubikStartDragRotation).add(new THREE.Euler(0, Math.PI * e.strength.x, 0, 'XYZ'));\n\t\t\trubikSpeedRotation.set(0, 0, 0, 'XYZ');\n\t\t}, (e) => {\n\t\t\trubikSpeedRotation.set(0, Math.PI * e.speed.x, 0, 'XYZ');\n\t\t});\n\t\tthis.dragListener = dragListener;\n\t\tthis.onWindowResize = this.onWindowResize.bind(this);\n\t\tthis.onMouseMove = this.onMouseMove.bind(this);\n\t\twindow.addEventListener('resize', this.onWindowResize, false);\n\t\tdocument.addEventListener('mousemove', this.onMouseMove, false);\n\t\tthis.section.classList.add('init');\n\n\t\tthis.play();\n\t\tthis.onWindowResize();\n\t}\n\n\tcreateSprite() {\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = 128;\n\t\tcanvas.height = 128;\n\t\tconst ctx = canvas.getContext('2d');\n\t\tconst gradient = ctx.createRadialGradient(\n\t\t\tcanvas.width / 2,\n\t\t\tcanvas.height / 2,\n\t\t\t0,\n\t\t\tcanvas.width / 2,\n\t\t\tcanvas.height / 2,\n\t\t\tcanvas.width / 2\n\t\t);\n\t\tgradient.addColorStop(0, 'rgba(255,255,255,1)');\n\t\tgradient.addColorStop(0.2, 'rgba(255,255,255,1)');\n\t\tgradient.addColorStop(0.22, 'rgba(255,255,255,.2)');\n\t\tgradient.addColorStop(1, 'rgba(255,255,255,0)');\n\t\tctx.fillStyle = gradient;\n\t\tctx.fillRect(0, 0, canvas.width, canvas.height);\n\t\treturn canvas;\n\t}\n\n\t/*\n\taddShadow(parent) {\n\t\tconst geometry = new THREE.PlaneGeometry(100, 100);\n\t\tgeometry.rotateX(-Math.PI / 4);\n\t\tconst material = new THREE.ShadowMaterial();\n\t\tmaterial.opacity = 0.2;\n\t\tconst mesh = new THREE.Mesh(geometry, material);\n\t\tmesh.position.z = -0.6;\n\t\tmesh.receiveShadow = true;\n\t\tparent.add(mesh);\n\t\treturn mesh;\n\t}\n\t*/\n\n\trandomRotateRubikRows(rows) {\n\t\t// console.log(rows);\n\t\tconst dir = Math.random() > 0.5 ? 1 : -1;\n\t\tconst row = rows[Math.floor(Math.random() * rows.length)];\n\t\tconst rotation = row.rotation;\n\t\tTweenMax.to(rotation, 0.5, {\n\t\t\ty: rotation.y + dir * Math.PI / 2,\n\t\t\tdelay: 1,\n\t\t\tease: Sine.easeInOut,\n\t\t\tonComplete: () => {\n\t\t\t\tthis.randomRotateRubikRows(rows);\n\t\t\t}\n\t\t});\n\t}\n\n\taddRubik(parent, rotation, texture) {\n\t\tconst group = new THREE.Group();\n\t\tconst step = 3;\n\t\tconst size = 1;\n\t\tconst rows = new Array(step).fill(null).map((dymmy, i) => {\n\t\t\tconst row = new THREE.Group();\n\t\t\tconst d = (step - size) / 2;\n\t\t\tconst position = new THREE.Vector3(0, i - d, 0);\n\t\t\trow.position.set(position.x, position.y, position.z);\n\t\t\tgroup.add(row);\n\t\t\treturn row;\n\t\t});\n\t\tconst cubes = new Array(step * step * step).fill(null).map((dummy, i) => {\n\t\t\tconst x = Math.floor(i / (step * step));\n\t\t\tconst y = Math.floor(i / step) % step;\n\t\t\tconst z = i % step;\n\t\t\tconst d = (step - size) / 2;\n\t\t\tconst row = rows[y];\n\t\t\t// const position = new THREE.Vector3(x - d, y - d, z - d);\n\t\t\tconst positionCube = new THREE.Vector3(x - d, 0, z - d);\n\t\t\t// console.log(x, y, z, positionCube);\n\t\t\treturn this.addCube(row, positionCube, texture);\n\t\t});\n\t\trubik.rows = rows;\n\t\trubik.cubes = cubes;\n\t\tgroup.rotation.set(rotation.x, rotation.y, rotation.z);\n\t\tparent.add(group);\n\t\tthis.randomRotateRubikRows(rows);\n\t\treturn group;\n\t}\n\n\taddCube(parent, position, texture) {\n\t\t// const geometry = new THREE.SphereGeometry(0.5, 48, 48);\n\t\tconst geometry = RoundBoxGeometry(1.0, 1.0, 1.0, 0.05, 2, 2, 2, 5);\n\n\t\t// const geometry2 = new THREE.IcosahedronGeometry(0.5, 4);\n\t\t// console.log(geometry2.vertices.length, geometry.vertices.length);\n\t\tconst material = new THREE.MeshStandardMaterial({\n\t\t\tcolor: '#fff',\n\t\t\troughness: 0.65,\n\t\t\tmetalness: 0.6,\n\t\t\tmap: texture,\n\t\t});\n\n\t\tconst materials = [\n\t\t\tmaterial,\n\t\t\tmaterial,\n\t\t\tmaterial,\n\t\t\tmaterial,\n\t\t\tmaterial,\n\t\t\tmaterial\n\t\t];\n\n\t\tconst mesh = new THREE.Mesh(geometry, materials);\n\t\tmesh.castShadow = true;\n\t\tmesh.receiveShadow = false;\n\t\tmesh.position.set(position.x, position.y, position.z);\n\t\tparent.add(mesh);\n\t\treturn mesh;\n\t}\n\n\taddParticles(parent) {\n\t\tconst texture = new THREE.CanvasTexture(this.createSprite());\n\t\tconst geometry = new THREE.Geometry();\n\t\tconst material = new THREE.PointsMaterial({\n\t\t\tsize: 0.07,\n\t\t\tmap: texture,\n\t\t\tvertexColors: THREE.VertexColors,\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\ttransparent: true\n\t\t});\n\t\tconst particles = new THREE.Points(geometry, material);\n\t\tconst points = this.cities.map((x) => {\n\t\t\treturn this.calcPosFromLatLonRad(x[0], x[1], 0.5);\n\t\t}).forEach((point, i) => {\n\t\t\tconst vertex = new THREE.Vector3();\n\t\t\tvertex.x = point.x;\n\t\t\tvertex.y = point.y;\n\t\t\tvertex.z = point.z;\n\t\t\tgeometry.vertices.push(vertex);\n\t\t\tgeometry.colors.push(new THREE.Color(0, 0, 0));\n\t\t});\n\t\tgeometry.mergeVertices();\n\t\tgeometry.verticesNeedUpdate = true;\n\t\tparticles.geometry = geometry;\n\t\tparent.add(particles);\n\t\treturn particles;\n\t}\n\n\tonWindowResize() {\n\t\tconst container = this.container,\n\t\t\trenderer = this.renderer,\n\t\t\tcamera = this.camera;\n\t\tconst size = {\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\taspect: 0,\n\t\t};\n\t\tsize.width = container.offsetWidth;\n\t\t/*\n\t\tTweenMax.set(container, {\n\t\t\theight: container.offsetWidth * 0.6\n\t\t});\n\t\t*/\n\t\tsize.height = container.offsetHeight;\n\t\tsize.aspect = size.width / size.height;\n\t\tif (renderer) {\n\t\t\trenderer.setSize(size.width, size.height);\n\t\t}\n\t\tif (camera) {\n\t\t\tif (USE_ORTHO) {\n\t\t\t\tconst width = 10; // !!! 3 - 10\n\t\t\t\tconst height = width / this.container.offsetWidth * this.container.offsetHeight;\n\t\t\t\tcamera.left = -width;\n\t\t\t\tcamera.right = width;\n\t\t\t\tcamera.top = height;\n\t\t\t\tcamera.bottom = -height;\n\t\t\t} else {\n\t\t\t\tcamera.aspect = size.width / size.height;\n\t\t\t}\n\t\t\tcamera.updateProjectionMatrix();\n\t\t}\n\t\tif (size.width < 1024) {\n\t\t\tthis.rubik.position.x = 0;\n\t\t} else {\n\t\t\tthis.rubik.position.x = -3;\n\t\t}\n\t}\n\n\tonMouseMove(e) {\n\t\tconst w2 = window.innerWidth / 2;\n\t\tconst h2 = window.innerHeight / 2;\n\t\tthis.mouse = {\n\t\t\tx: (e.clientX - w2) / w2,\n\t\t\ty: (e.clientY - h2) / h2,\n\t\t};\n\t\t// console.log('onMouseMove', this.mouse);\n\t}\n\n\tdoParallax() {\n\t\t// parallax\n\t\tconst parallax = this.parallax;\n\t\tparallax.x += (this.mouse.x - parallax.x) / 8;\n\t\tparallax.y += (this.mouse.y - parallax.y) / 8;\n\t\t//\n\t\tconst titleXy = {\n\t\t\tx: -50 + 0.5 * -parallax.x,\n\t\t\ty: -50 + 0.5 * -parallax.y,\n\t\t};\n\t\tTweenMax.set(this.title, {\n\t\t\ttransform: 'translateX(' + titleXy.x + '%) translateY(' + titleXy.y + '%)'\n\t\t});\n\t\tconst shadowXy = {\n\t\t\tx: -50 + 3 * -parallax.x,\n\t\t\ty: -50 + 3 * -parallax.y,\n\t\t};\n\t\tTweenMax.set(this.shadow, {\n\t\t\ttransform: 'translateX(' + shadowXy.x + '%) translateY(' + shadowXy.y + '%)'\n\t\t});\n\t\tthis.directional1.position.set(parallax.x * 0.3, 2 + parallax.y * 0.3, 0.5);\n\t\tthis.directional2.position.set(parallax.x * 0.3, -2 + parallax.y * 0.3, 0);\n\t}\n\n\trender(delta) {\n\t\tif (!this.dragListener.dragging) {\n\t\t\tthis.rubikRotation.y += this.rubikSpeedRotation.y;\n\t\t\tthis.rubikSpeedRotation.y += (0.002 - this.rubikSpeedRotation.y) / 50;\n\t\t}\n\t\tthis.rubik.rotation.copy(this.rubikRotation).add(this.rubikDragRotation);\n\t\tthis.particles.geometry.vertices.forEach((vertex, i) => {\n\t\t\tconst local = this.rubik.localToWorld(vertex.clone());\n\t\t\tconst distance = local.distanceTo(this.particleRef);\n\t\t\tconst s = Math.max(0, Math.min(1, (1 - distance))) * 5;\n\t\t\tthis.particles.geometry.colors[i] = new THREE.Color(s, s, s);\n\t\t\tthis.particles.geometry.colorsNeedUpdate = true;\n\t\t});\n\t\tthis.renderer.render(this.scene, this.camera);\n\t\tthis.doParallax();\n\t}\n\n\tplay() {\n\t\tconst clock = new THREE.Clock();\n\t\tconst loop = (time) => {\n\t\t\tconst delta = clock.getDelta();\n\t\t\tthis.render(delta);\n\t\t\twindow.requestAnimationFrame(loop);\n\t\t};\n\t\tloop();\n\t}\n\n\tcalcPosFromLatLonRad(lat, lon, radius) {\n\t\tconst phi = (90 - lat) * (Math.PI / 180);\n\t\tconst theta = (lon + 180) * (Math.PI / 180);\n\t\tconst x = -((radius) * Math.sin(phi) * Math.cos(theta));\n\t\tconst z = ((radius) * Math.sin(phi) * Math.sin(theta));\n\t\tconst y = ((radius) * Math.cos(phi));\n\t\treturn new THREE.Vector3(x, y, z);\n\t}\n\n}\n\nvar rubik = new Rubik();\n\nwindow.onload = () => {\n\trubik.init();\n};\n"],"file":"docs/js/rubik.js"}